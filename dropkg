#!/usr/bin/env perl

use strict;
use warnings;
use Archive::Tar;
use File::Copy;
use File::Find;
use File::Path qw( make_path remove_tree);
use Getopt::Std;
use Cwd;
use Time::HiRes qw( usleep );
use autodie;

our $VERSION = "v1.8";

delete @ENV{ qw( IFS CDPATH ENV BASH_ENV ) };

my %opt;
getopts('tvmh', \%opt);


sub os{
    open my $os, '-|', 'uname -a';
    while(<$os>){
        if( /iPhone|iPad/ && /arm64/ ){ return 'iphoneos-arm64' }
        if( /iPhone|iPad/ ){ return 'iphoneos-arm' }
        if( /Darwin/ ){ return 'osx' }
        if( /Ubuntu/ ){ return 'ubuntu' }
    }
}

sub debian_manual{
        open my $openph, '-|', 'which', 'open';
        while(<$openph>){
            chomp;
            if( /\/open$/ ){
                system("open 'https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Package'");
            } else { print "see Debian Policy Manual at https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Package\n" }
        }
}


my %dropkg = ( animation => 1 );
sub conf{
    if( -f "$ENV{HOME}/.dropkg" ){
        open my $conf, '<', "$ENV{HOME}/.dropkg";
        while(<$conf>){
            my( $field, $value ) = split /:\s+/, $_;
                $dropkg{$field} = $value;
            }
        }
}


sub deps{
    my $ar;
    my $tree;

    open( my $deps, "-|", 'which', 'ar', 'tree' );
    while(<$deps>){
        chomp;
        if( /\/ar$/ ){ $ar = 1 }
        if( /\/tree$/ ){ $tree = 1 }
    }

    unless( $ar ){ print "'ar' dependency is missing. Please use cpan to install it 'cpan PerlPowerTools'.\n" and exit }
    unless( $tree ){ print "'tree' dependency is missing. Please use cpan to install it 'cpan Filesys::Tree'.\n" and exit }
}



my %control;
if( -f "$ENV{HOME}/dropkg_control" ){
    open my $fh, "<", "$ENV{HOME}/dropkg_control";
    while(<$fh>){
        chomp;
        my( $field, $value ) = split /:\s+/, $_;
        $control{$field} = $value;
    }
} else {
            %control = ( Author => '(mandatory)',
                        Version => '(mandatory)',
                        Name    => '(mandatory)',
                        Package => '(mandatory)',
                        Source  => '(optional)',
                        Section => '(recomended)',
                        Priority => '(recomended)',
                        Architecture => '(mandatory)',
                        Esential    => '(optional)',
                        Depends => '(mandatory if package has dependencies)',
                        'Installed-Size'  => '(optional)',
                        Maintainer  => '(mandatory)',
                        Description => '(mandatory)',
                        Homepage    => '(optional)',
                        'Built-Using' => 'dropkg'
            );
}

sub start{
    my %seen = ( control => 0, deb => 0 );
    my @deb;

    opendir( my $dh, '.' );
    for( readdir $dh ){
        if( /^control$/ ){
            $seen{control}++;
        }

        if( /(.*\.deb)$/ ){
            $seen{deb}++;
            push @deb, $1;
        }
    }
    closedir $dh;

    if( $seen{control} > 0 and $seen{deb} > 0 ){ print "there are control and .deb files in current directory\n" and exit } 
    if( $seen{deb} > 1 ){
        if( $ARGV[0] ){
            unpackdeb($ARGV[0]);
        } else {
            print "there is more than one one .deb file in current directory, choose one:\n";
            opendir(my $dh, '.');
            my @deb = grep{/\.deb$/}readdir($dh);
            print "$_\n" for @deb;
            exit
        }
    }
    if( $seen{control} == 0 and $seen{deb} == 0 ){ print "there is no control or .deb file in current directory\n" and  exit }
    if( $seen{control} == 1 and $seen{deb} == 0 ){
    
        my %control_file;
        open my $rfh, '<', './control';
        while(<$rfh>){
            chomp;
            my( $field, $value ) = split /:\s/, $_;
            $control_file{$field} = $value;
        }
        close $rfh;

        for( keys %control ){
            delete $control{$_} unless ( $control{$_} eq '(mandatory)' );
        }

        my @missing;
        for( keys %control ){
            push( @missing, $_ ) unless $control_file{$_};
        }

        if( @missing ){
            print "control file is missing mandatory fields: "; print "$_, " for @missing; print "\n";
            exit;
        }

        $control_file{'Installed-Size'} = installed_size();
    
        if( defined $opt{t} ){
            for( keys %control ){
                print "$_: $control{$_}\n";
            } exit;
        }

        open my $wfh,'>', 'control';
        for( keys %control_file ){
            print $wfh "$_: $control_file{$_}\n";
        }
        close $wfh;
        
        packdir( debname() );
    }
    if( $seen{control} == 0 and $seen{deb} == 1 ){ unpackdeb($deb[0]) }
}


sub dropkg{
    my $term_height = 0;
    open my $tput_lines, '-|', 'tput', 'lines';
    while(<$tput_lines>){
        chomp( $term_height = $_ );
    }
    close $tput_lines;
    system('clear');
    my $ps1 = $ENV{PS1};
    $ENV{PS1} = ' ';

    my $usleep = 130000;
    for( 0..16 ){
        $usleep = $usleep - 8000;
        if( $usleep < 8000 ){ $usleep = 8000 }

        #if( $_ == 1 ){ print "d\n" }
        #elsif( $_ == 2 ){ print "r\n" }
        #elsif( $_ == 4 ){ print "o\n" }
        #elsif( $_ == 7 ){ print "p\n" }
        #elsif( $_ == 11 ){ print "k\n" }
        #elsif( $_ == 16 ){ print "g\n" }
        #else { print "\n" }
        print "\n";

        usleep( $usleep );
    }

    open my $lsp, '-|', 'ls';
    while(<$lsp>){ print }

    $ENV{PS1} = $ps1;
}

sub tree{
    print "tree\n";
}

sub installed_size{
    my $size = 0;
    find{ untaint => 1, wanted => sub { $size += -s } }, ('.');
    return $size;
}

sub debname{
    my %control_file;
    open my $fh, '<', 'control';
    while(<$fh>){
        chomp;
        my( $field, $value ) = split /:\s/, $_;
        $control_file{$field} = $value;
    }
    my $debname = $ARGV[0] ? $ARGV[0] : "$control_file{Name}_$control_file{Version}_$control_file{Architecture}.deb";
}

sub packdir{
    my $debname = shift;
    if( $ENV{PWD} eq $ENV{HOME} ){ print "You are in your home directory, create new directory and place your files in it\n" and die }
    if( $ENV{PWD} eq '/' ){ print "You are in root directory, create new directory and place your files in it\n" and die }


    remove_tree('DEBIAN');

    copy('./control', './.control') and unlink 'control';
    if( -f './postinst' ){ copy('./postinst', './.postinst') and unlink './postinst' }
    if( -f './prerm' ){ copy('./prerm', './.prerm' ) and unlink './prerm' }

    #<---------
    my @pack_content = ();
    find{ untaint => 1, wanted => sub { 
        unless( /^\.$|^\.control$|^\.postinst$|^\.prerm$/ ) { push @pack_content, "$File::Find::dir/$_" }
    } }, ('.');

    my $tar_type = '';
    open my $tar_type_ph, '-|', 'tar --version';
    while(<$tar_type_ph>){
	    if(/GNU/){ $tar_type = 'GNU' }
	    if(/bsd/){ $tar_type = 'bsd' }
    }
    close $tar_type_ph;
    
    if( $tar_type eq 'GNU' ){
    	system("tar --hard-dereference -czf ../data.tar.gz @pack_content");
    } elsif( $tar_type eq 'bsd' ){
	system("tar -czf ../data.tar.gz @pack_content");
    } else { die "unrecognized tar type\n" }
    #<---------
    make_path('DEBIAN');

    chdir 'DEBIAN';
    
    copy('../.control', 'control') and unlink '../.control';
    if( -f '../.postinst'){ copy('../.postinst', 'postinst') and unlink '../.postinst' }
    if( -f '../.prerm'){ copy('../.prerm', 'prerm') and unlink '../.prerm' }

    my $control = Archive::Tar->new;
    $control->add_files( <*> );
    $control->write('../../control.tar.gz', COMPRESS_GZIP);

    open my $fh, '>', '../../debian-binary';
    print $fh "2.0\n";
    close $fh;

    chdir '..';
    for( <*> ){
        remove_tree $_ if -d $_;
        unlink $_ if -f $_;
    }
    
    my $cwd = getcwd();
    chdir '..';
    
    open SAVEERR, ">& STDERR";
    open STDERR, '>', undef;;
    select STDERR; $| = 1;
        
    my @file = ( 'debian-binary', 'control.tar.gz', 'data.tar.gz' );
    open my $arr, '-|', "ar -r $debname @file";
    while(<$arr>){ print }

    close STDERR;
    open STDERR, ">&SAVEERR";
            
    unlink('debian-binary', 'control.tar.gz', 'data.tar.gz' );
    chdir $cwd;
    copy("../$debname", '.');
    unlink "../$debname";

    if( $dropkg{animation} == 1 ){
        dropkg();
    } else { 
        open my $lsp, '-|', 'ls';
        while(<$lsp>){ print }
    }
}

sub unpackdeb {
    my $deb = shift;
    unless( -f $deb ){ print "File $deb is not in current directory.\n" }

    system( "ar -x $deb");
    unlink("$deb", 'debian-binary');

    my $control = Archive::Tar->new;
    $control->read('control.tar.gz') and $control->extract();
    unlink 'control.tar.gz';

    my $data = Archive::Tar->new;
    $data->read('data.tar.gz') and $data->extract();
    unlink 'data.tar.gz';
    
    open my $tree, '-|', 'tree';
    while(<$tree>){ print }
    close $tree;
}

sub help {
	print "\nalios" . " - creates debian binary packages\n\n";
	print "Usage:\n\twithout any option 'dropkg' creates .deb package if there is a 'control' file in current directory. If there is a '.deb' package it will unpack it.\n\n";
	print "\t" . "-v  show version\n";
	print "\t" . "-t  print control file template\n";
	print "\t" . "-m  open debian policy manual\n\n";
}


if( $opt{t} ){
    print "$_: $control{$_}\n" for keys(%control);
} elsif( $opt{m} ){
    debian_manual();
} elsif( $opt{h} ){
    help();
} elsif( $opt{v} ){
    print "$VERSION\n";
} else {
    conf();
    deps();
    start();
}


=encoding utf8

=head1 NAME

dropkg - creates debian binary packages

=head1 VERSION

This document describes alios version 1.8

=head1 SYNOPSIS

=over 10

=item Without any option dropkg creates debian bianry package with contents of current directory if there is control file in it. If there is debian package in current directory dropkg will unkack it into current directory.


=item C<-v> show version

=item C<-t> show control file template  

=item C<-m> show debian policy manual 

=back

=head1 DESCRIPTION

Creates debian bianry package with contents of current directory if there is control file in it. If there is debian package in current directory dropkg will unkack it into current directory.

=head1 EXAMPLES

=over 10

=item To create .deb package:

You want to create .deb package that will install your program 'myprg' into '/usr/bin' directory. Create empty directory of any name (think of it as root '/' directory) then create 'usr/bin' path in that directory and move your program into that path.

C<mkdir MyTmp>

C<mkdir -p MyTmp/usr/bin>

C<mv myprg MyTmp/usr/bin>

C<cd MyTmp>

Place 'control' file into 'MyTmp' directory. C<dropkg -t> can print you template of control file.

C<dropkg>

Name of .deb file is taked from control file, Name + Version + Architecture + .deb.
To have different .deb filename pass it as 1st parameter C<dropkg myprg.deb>. 

=item To unpack .deb package:

Go into directory that contains .deb package and run C<dropkg> without any option.

=back

=head1 DEVELOPMENT

dropkg is hosted on L<github|https://github.com/z448/dropkg>. You can track and contribute to its development there.

=head1 AUTHOR

Zdeněk Bohuněk, C<< <4zdenek@gmail.com> >>

=head1 COPYRIGHT

Copyright © 2016-2023, Zdeněk Bohuněk C<< <4zdenek@gmail.com> >>. All rights reserved. 

This code is available under the Artistic License 2.0.

=cut
