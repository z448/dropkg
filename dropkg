#!/usr/bin/env perl

use strict;
use warnings;
use Archive::Tar;
use File::Copy;
use File::Find;
use File::Path qw( make_path remove_tree);
use Getopt::Std;
use Cwd;
use Time::HiRes qw( usleep );
use autodie;

our $VERSION = "v1.9.8";

delete @ENV{ qw( IFS CDPATH ENV BASH_ENV ) };

my %opt;
getopts('tvmh', \%opt);


sub debian_manual{
        open my $openph, '-|', 'which', 'open';
        while(<$openph>){
            chomp;
            if( /\/open$/ ){
                system("open 'https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Package'");
            } else { print "see Debian Policy Manual at https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Package\n" }
        }
}


my %dropkg = ( animation => 1, deb_name => "Package_Version_Architecture" );
sub conf{
    if( -f "$ENV{HOME}/.dropkg" ){
        open my $conf, '<', "$ENV{HOME}/.dropkg";
        while(<$conf>){
            my( $field, $value ) = split /:\s+/, $_;
            $dropkg{$field} = $value;
	}
    }
}


sub dep{
    my $dep = shift || 0;
    my %dep = ( ar => 0, tree => 0, tar => 0, xz => 0 );


    open( my $depph, "-|", 'which', $dep );
    while(<$depph>){
        chomp;
        if( /\/$dep$/ ){
            $dep{$dep} = 1;
            if( $dep eq 'tar' ){
                open( my $tarph, '-|', 'tar', '--version' );
                while(<$tarph>){
	                if(/GNU/){ $dep{$dep} = 'gnu' }
	                if(/bsdtar/){ $dep{$dep} = 'bsd' }
                }
                close $tarph;
            }
        }
    }
    return $dep{$dep};
}

unless( dep('ar') ){ print "'ar' dependency is missing. Please use cpan to install it 'cpan PerlPowerTools'.\n" and exit }
unless( dep('tree') ){ print "'tree' dependency is missing. Please use cpan to install it 'cpan Filesys::Tree'.\n" and exit }

my %control;
if( -f "$ENV{HOME}/dropkg_control" ){
    open my $fh, "<", "$ENV{HOME}/dropkg_control";
    while(<$fh>){
        chomp;
        my( $field, $value ) = split /:\s+/, $_;
        $control{$field} = $value;
    }
} else {
            %control = ( Author => '(optional)',
                        Version => '(mandatory)',
                        Name    => '(optional)',
                        Package => '(mandatory)',
                        Source  => '(optional)',
                        Section => '(recomended)',
                        Priority => '(recomended)',
                        Architecture => '(mandatory)',
                        Esential    => '(optional)',
                        Depends => '(mandatory if package has dependencies)',
                        'Installed-Size'  => '(optional)',
                        Maintainer  => '(mandatory)',
                        Description => '(mandatory)',
                        Homepage    => '(optional)',
                        Suggests    => '(optional)',
                        Recommends   => '(optional)',
                        ' '    => '(optional) Place for extended description'
            );
}

sub start{
    my %seen = ( control => 0, deb => 0 );
    my @deb;

    opendir( my $dh, '.' );
    for( readdir $dh ){
	if( /^control$/ ){
            $seen{control}++;
        }

        if( /(.*\.deb)$/ ){
            $seen{deb}++;
            push @deb, $1;
        }
    }
    closedir $dh;

    if( $seen{control} > 0 and $seen{deb} > 0 ){ print "there are control and .deb files in current directory\n" and exit } 
    if( $seen{deb} > 1 ){
        if( $ARGV[0] ){
            unpackdeb($ARGV[0]);
        } else {
            print "there is more than one one .deb file in current directory, choose one:\n";
            opendir(my $dh, '.');
            my @deb = grep{/\.deb$/}readdir($dh);
            print "$_\n" for @deb;
            exit
        }
    }
    if( $seen{control} == 0 and $seen{deb} == 0 ){ print "there is no control or .deb file in current directory\n" and  exit }
    if( $seen{control} == 1 and $seen{deb} == 0 ){
    
        my %control_file;
	my $ed_count = 0;
        open my $rfh, '<', './control';
        while(<$rfh>){
            chomp;
	    if(/(^\ )(.*)/){
		    $ed_count++;
		    $control_file{$ed_count} = $2;
	    } else {
		    my( $field, $value ) = split /:\s/, $_;
		    $control_file{$field} = $value;
	    }
        }
        close $rfh;

        for( keys %control ){
            delete $control{$_} unless ( $control{$_} eq '(mandatory)' );
        }

        my @missing;
        for( keys %control ){
            push( @missing, $_ ) unless $control_file{$_};
        }

        if( @missing ){
            print "control file is missing mandatory fields: "; print "$_, " for @missing; print "\n";
            exit;
        }

	$control_file{'Installed-Size'} = installed_size();
    
        if( defined $opt{t} ){
            for( keys %control ){
                print "$_: $control{$_}\n";
            } exit;
        }

        open my $wfh,'>', 'control';
	print $wfh "Name: $control_file{Name}\n" if exists $control_file{Name};
	print $wfh "Package: $control_file{Package}\n" if exists $control_file{Package};
	print $wfh "Author: $control_file{Author}\n" if exists $control_file{Author};
	print $wfh "Version: $control_file{Version}\n" if exists $control_file{Version};
	print $wfh "Architecture: $control_file{Architecture}\n" if exists $control_file{Architecture};
	print $wfh "Maintainer: $control_file{Maintainer}\n" if exists $control_file{Maintainer};
	print $wfh "Installed-Size: $control_file{'Installed-Size'}\n" if exists $control_file{'Installed-Size'};
	print $wfh "Depends: $control_file{'Depends'}\n" if exists $control_file{'Depends'};
	print $wfh "Recommends: $control_file{'Recommends'}\n" if exists $control_file{'Recommends'};
	print $wfh "Suggests: $control_file{'Suggests'}\n" if exists $control_file{'Suggests'};
	print $wfh "Section: $control_file{'Section'}\n" if exists $control_file{'Section'};
	print $wfh "Priority: $control_file{'Priority'}\n" if exists $control_file{'Priority'};
	print $wfh "Homepage: $control_file{'Homepage'}\n" if exists $control_file{'Homepage'};
	print $wfh "Description: $control_file{'Description'}\n" if exists $control_file{'Description'};
	for(1..$ed_count){ print $wfh " $control_file{$_}\n" if exists $control_file{$_} };
        close $wfh;
        
        packdir( debname() );
    }
    if( $seen{control} == 0 and $seen{deb} == 1 ){ unpackdeb($deb[0]) }
}


sub dropkg{
    my $term_height = 0;
    open my $tput_lines, '-|', 'tput', 'lines';
    while(<$tput_lines>){
        chomp( $term_height = $_ );
    }
    close $tput_lines;
    system('clear');
    my $ps1 = $ENV{PS1};
    $ENV{PS1} = ' ';

    my $usleep = 130000;
    for( 0..16 ){
        $usleep = $usleep - 8000;
        if( $usleep < 8000 ){ $usleep = 8000 }

        #if( $_ == 1 ){ print "d\n" }
        #elsif( $_ == 2 ){ print "r\n" }
        #elsif( $_ == 4 ){ print "o\n" }
        #elsif( $_ == 7 ){ print "p\n" }
        #elsif( $_ == 11 ){ print "k\n" }
        #elsif( $_ == 16 ){ print "g\n" }
        #else { print "\n" }
	    print "\n";

        usleep( $usleep );
    }

    $ENV{PS1} = $ps1;
}

sub installed_size{
    my $size = 0;
    find{ untaint => 1, wanted => sub { if( -f $_){ $size += -s } } }, ('.');
    $size;
}

sub debname{
    my %control_file;
    open my $fh, '<', 'control';
    while(<$fh>){
        chomp;
        my( $field, $value ) = split /:\s/, $_;
        $control_file{$field} = $value;
    }
    my $debname = $ARGV[0] ? $ARGV[0] : "$control_file{Package}_$control_file{Version}_$control_file{Architecture}.deb";
}


sub packdir{
    my $debname = shift;
    if( $ENV{PWD} eq $ENV{HOME} ){ print "You are in your home directory, create new directory and place your files in it\n" and exit }
    if( $ENV{PWD} eq '/' ){ print "You are in root directory, create new directory and place your files in it\n" and exit }

    remove_tree('DEBIAN');

    my @data = ();
    opendir(my $dh, '.') || die "Can't open directory: $!";
    while( readdir $dh ){
        unless( /^\.$|^\.\.$|^control$|^preinst$|^postinst$|^prerm$|^postrm$|^conffiles$|^shlibs$|^triggers$/ ) { push @data, $_ }
    }
    closedir $dh;

    my $has_xz = dep('xz');
    if( $has_xz ){
	    system("tar -cf - @data | xz -9 -c - > data.tar.xz");
    } else { system("tar -czf data.tar.gz @data") }
    
    make_path('DEBIAN');
    chdir 'DEBIAN';
    
    copy('../control', 'control') and unlink '../control';
    if( -f '../preinst'){ copy('../preinst', 'preinst') and unlink '../preinst' }
    if( -f '../postinst'){ copy('../postinst', 'postinst') and unlink '../postinst' }
    if( -f '../prerm'){ copy('../prerm', 'prerm') and unlink '../prerm' }
    if( -f '../postrm'){ copy('../postrm', 'postrm') and unlink '../postrm' }
    if( -f '../conffiles'){ copy('../conffiles', 'conffiles') and unlink '../conffiles' }
    if( -f '../shlibs'){ copy('../shlibs', 'shlibs') and unlink '../shlibs' }
    if( -f '../triggers'){ copy('../triggers', 'triggers') and unlink '../triggers' }
    #md5sums


    my @control = ();
    find{ untaint => 1, wanted => sub{
	    if( -f ){ push @control, "$File::Find::dir/$_" }
    } }, ('.');


    if( $has_xz ){
	    system("tar -cf - @control | xz -9 -c - > ../control.tar.xz");
    } else { system("tar -czf ../control.tar.gz @control") }

    open my $fh, '>', '../debian-binary';
    print $fh "2.0\n";
    close $fh;

    chdir '..';
    for( <*> ){
        next if(/^debian-binary$|^data\.tar\.|control\.tar/);
        remove_tree $_ if -d $_;
        unlink $_ if -f $_;
    }

    open SAVEERR, ">& STDERR";
    open SAVEOUT, ">& STDOUT";
    open STDOUT, ">", undef;;
    open STDERR, ">& STDOUT";
    select STDERR; $| = 1;
    select STDOUT; $| = 1;
    
    if( $has_xz ){
	    system("ar -r $debname debian-binary control.tar.xz data.tar.xz");
    } else {
	    system("ar -r $debname debian-binary control.tar.gz data.tar.gz") }

    close STDOUT;
    close STDERR;
    open STDOUT, ">&SAVEOUT";
    open STDERR, ">&SAVEERR";

    unlink('./debian-binary');

    if( $has_xz ){
	    unlink('./control.tar.xz', './data.tar.xz');
    } else { unlink('./control.tar.gz', './data.tar.gz') }

    dropkg() if( $dropkg{animation} == 1 );
    open my $lsp, '-|', 'ls';
    while(<$lsp>){ print }
    close $lsp;
}

sub unpackdeb {
    my $deb = shift;
    unless( -f $deb ){ print "File $deb is not in current directory.\n" }

    system( "ar -x $deb");
    unlink("$deb", 'debian-binary');

    my @control_data_file = ();
    find{ untaint => 1, wanted => sub{
	    if( /^control\.tar\.(gz|xz|lzma)$|^data\.tar\.(gz|xz|lzma)$/){ push @control_data_file, $_ }
    } }, ('.');

    open SAVEERR, ">& STDERR";
    open SAVEOUT, ">& STDOUT";
    open STDOUT, ">", undef;;
    open STDERR, ">& STDOUT";
    select STDERR; $| = 1;
    select STDOUT; $| = 1;

    system("tar -xvf $control_data_file[0]");
    system("tar -xvf $control_data_file[1]");

    close STDOUT;
    close STDERR;
    open STDOUT, ">&SAVEOUT";
    open STDERR, ">&SAVEERR";

    unlink @control_data_file;

    open my $tree, '-|', 'tree';
    while(<$tree>){ print }
    close $tree;
}

sub help {
	print "\nalios" . " - creates debian binary packages\n\n";
	print "Usage:\n\twithout any option 'dropkg' creates .deb package if there is a 'control' file in current directory. If there is a '.deb' package it will unpack it.\n\n";
	print "\t" . "-v  show version\n";
	print "\t" . "-t  print control file template\n";
	print "\t" . "-m  open debian policy manual\n\n";
}


if( $opt{t} ){
    print "$_: $control{$_}\n" for keys(%control);
} elsif( $opt{m} ){
    debian_manual();
} elsif( $opt{h} ){
    help();
} elsif( $opt{v} ){
    print "$VERSION\n";
} else {
    conf();
    dep();
    start();
}


=encoding utf8

=head1 NAME

dropkg - creates debian binary packages

=head1 VERSION

This document describes dropkg version 1.9.5

=head1 SYNOPSIS

=over 10

=item Without any option dropkg creates debian bianry package with contents of current directory if there is control file in it. If there is debian package in current directory dropkg will unkack it into current directory.


=item C<-v> show version

=item C<-t> show control file template  

=item C<-m> show debian policy manual 

=back

=head1 DESCRIPTION

Creates debian bianry package with contents of current directory if there is control file in it. If there is debian package in current directory dropkg will unkack it into current directory.

=head1 EXAMPLES

=over 10

=item To create .deb package:

You want to create .deb package that will install your program 'myprg' into '/usr/bin' directory. Create empty directory of any name (think of it as root '/' directory) then create 'usr/bin' path in that directory and move your program into that path.

C<mkdir MyTmp>

C<mkdir -p MyTmp/usr/bin>

C<mv myprg MyTmp/usr/bin>

C<cd MyTmp>

Place 'control' file into 'MyTmp' directory. C<dropkg -t> can print you template of control file.

C<dropkg>

Name of .deb file is taked from control file, Name + Version + Architecture + .deb.
To have different .deb filename pass it as 1st parameter C<dropkg myprg.deb>. 

=item To unpack .deb package:

Go into directory that contains .deb package and run C<dropkg> without any option. If there is more than one .deb file in current directory pass file name as first argument C<dropkg file.deb>.

=back

=head1 DEVELOPMENT

dropkg is hosted on L<github|https://github.com/z448/dropkg>. You can track and contribute to its development there.

=head1 AUTHOR

Zdeněk Bohuněk, C<< <zdenek@cpan.org> >>

=head1 COPYRIGHT

Copyright © 2016-2023, Zdeněk Bohuněk C<< <zdenek@cpan.org> >>. All rights reserved.

This code is available under the Artistic License 2.0.

=cut
